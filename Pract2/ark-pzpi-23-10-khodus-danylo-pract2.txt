МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»



ЗВІТ
з практичної роботи
з дисципліни «Аналіз та рефакторінг коду»
на тему «Методи рефакторингу: Remove Setting Method, Hide Method, Remove Parameter для мови програмування TypeScript»

 

Виконав:
ст. гр. ПЗПІ-23-10
Ходус Д.Є.

Перевірив:
старший викл. Кафедри ПІ
Сокорчук І.П.


Харків 2025

1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
05.11.2025
0.1
 Створено розділ “Завдання”, “Опис виконаної роботи”,”Висновки”
2
05.11.2025
0.1
Створено “Додаток Б”,“Додаток В”
3
06.11.2025
0.1
Створено “Додаток A”
         
2 ЗАВДАННЯ
      Мета роботи
     Метою моєї роботи було вивчення та аналіз методів рефакторингу коду мовою програмування TypeScript, зокрема таких прийомів, як Remove Setting Method, Hide Method та Remove Parameter. У ході роботи я прагнув(ла) дослідити призначення, особливості та переваги кожного з цих методів, а також зрозуміти, як їх застосування впливає на структуру, гнучкість і підтримуваність програмного коду.
     Також метою було сформувати цілісне уявлення про роль рефакторингу у процесі розробки програмного забезпечення мовою TypeScript, його значення для підвищення якості коду, покращення інкапсуляції, зменшення надлишкових залежностей і спрощення логіки програм. Розуміння принципів використання зазначених методів сприяє створенню більш чистих, зрозумілих і масштабованих TypeScript-додатків.


      3 ОПИС ВИКОНАНОЇ РОБОТИ
      Хід Роботи
     3.1 Вступ
     Рефакторинг — це дисциплінований процес зміни внутрішньої структури програмного коду, що не впливає на його зовнішню поведінку. Основна мета рефакторингу полягає не у додаванні нової функціональності, а у покращенні якості вже існуючого коду: його дизайну, архітектури, читабельності та простоти у підтримці.
     У процесі розробки на TypeScript, як і на будь-якій іншій мові, код може ставати надмірно складним, заплутаним або важким для модифікації. Це призводить до появи "кодових запахів" (code smells) — ознак проблем у дизайні системи. Рефакторинг є ключовим інструментом для боротьби з технічним боргом та підтримки кодової бази у здоровому стані.
     У цій роботі детально розглянуто три фундаментальні методи рефакторингу для мови TypeScript: Remove Setting Method, Hide Method та Remove Parameter. Ці техніки спрямовані на посилення інкапсуляції, спрощення публічних інтерфейсів класів та усунення надлишковості, що робить код більш надійним, зрозумілим і гнучким до майбутніх змін.
     3.2 Методи рефакторингу, що розглядаються
     3.2.1 Remove Setting Method (Видалення методу-сетера)
     Метод рефакторингу Remove Setting Method застосовується у випадках, коли поле об'єкта повинно ініціалізуватися лише один раз під час створення об'єкта (в конструкторі) і не повинно змінюватися протягом його життєвого циклу. Наявність публічного сетера (setting method) для такого поля порушує цей принцип, створюючи можливість для неконтрольованої зміни стану об'єкта ззовні.
     Наприклад, у класі Order (Замовлення) поле orderId є унікальним ідентифікатором, який не повинен змінюватися після створення замовлення. Однак, якщо клас має публічний метод setOrderId(), це створює ризик, що ідентифікатор буде випадково або навмисно змінено, що може призвести до серйозних помилок у логіці системи (Див. додаток В.1).
     Після застосування рефакторингу метод setOrderId() видаляється, а поле orderId позначається модифікатором readonly. Це гарантує, що його значення можна присвоїти лише в конструкторі класу, забезпечуючи незмінність (імутабельність) ідентифікатора. Такий підхід робить поведінку об'єкта більш передбачуваною та безпечною (Див. додаток В.2).
     3.2.2 Hide Method (Приховування методу)
     Метод Hide Method використовується, коли певний метод класу не призначений для використання ззовні (іншими класами), а є лише допоміжним інструментом для реалізації внутрішньої логіки. Якщо такий метод залишається публічним, він без потреби розширює публічний інтерфейс (API) класу, ускладнюючи його розуміння та використання. Крім того, це створює ризик, що зовнішній код почне залежати від внутрішньої деталі реалізації, яку в майбутньому може знадобитися змінити.
     Розглянемо клас ReportGenerator, який має публічний метод generateReport(). Для своєї роботи цей метод може викликати інші допоміжні методи, наприклад fetchDataFromDB() та formatData(). Якщо ці допоміжні методи є публічними, їх може викликати будь-який інший об'єкт, хоча вони не є частиною основного функціоналу, що надається класом (Див. додаток В.3).
     Застосування рефакторингу полягає у зміні модифікатора доступу цих допоміжних методів з public на private. Після цього вони стають недоступними ззовні і можуть використовуватися лише всередині класу ReportGenerator. Це спрощує публічний API класу, посилює інкапсуляцію та дає змогу вільно змінювати внутрішню реалізацію, не боячись зламати зовнішній код (Див. додаток В.4).
     3.2.3 Remove Parameter (Видалення параметра)
     Цей метод рефакторингу застосовується, коли метод має параметр, який більше не використовується всередині його тіла, або коли значення цього параметра можна отримати іншим, більш надійним шляхом всередині самого методу (наприклад, з поля класу). Наявність невикористовуваного або надлишкового параметра робить сигнатуру методу складнішою і може вводити в оману розробників, які будуть його викликати.
     Наприклад, у класі User є поле username та метод createWelcomeMessage(), який приймає name як параметр, хоча це ім'я є іменем самого користувача. Це призводить до надлишкового коду при виклику методу, де потрібно передавати дані, які об'єкт уже має (Див. додаток В.5).
     Рефакторинг полягає у видаленні зайвого параметра з визначення методу та з усіх його викликів. Всередині методу для отримання потрібного значення тепер використовується поле класу (this.username). В результаті сигнатура методу стає простішою, а код — чистішим і менш схильним до помилок, пов'язаних з передачею некоректних параметрів (Див. додаток В.6). Це також покращує згуртованість класу, оскільки метод тепер покладається на власні дані.


      4 ВИСНОВКИ
     У результаті виконання роботи було досліджено сутність та практичне застосування трьох ключових методів рефакторингу програмного коду на TypeScript — Remove Setting Method, Hide Method та Remove Parameter. Кожен із цих методів вирішує конкретні проблеми, пов’язані з інкапсуляцією, дизайном інтерфейсів та чистотою коду.
     Під час аналізу методу Remove Setting Method було з’ясовано, що він є потужним інструментом для забезпечення незмінності (імутабельності) стану об'єкта. Видалення публічних сетерів для полів, що не повинні змінюватися після ініціалізації, робить поведінку класів більш передбачуваною та безпечною. Такий підхід запобігає випадковим або несанкціонованим змінам даних, що є критично важливим для підтримки цілісності стану в складних системах.
     Метод Hide Method продемонстрував важливість сильної інкапсуляції та мінімізації публічного API класу. Приховуючи допоміжні методи (роблячи їх приватними), ми зменшуємо кількість точок взаємодії із класом, залишаючи зовні лише необхідний функціонал. Це не тільки спрощує використання класу, але й надає розробникам свободу змінювати внутрішню реалізацію без ризику зламати залежний код, що значно підвищує гнучкість та довгострокову підтримуваність проєкту.
     Метод Remove Parameter довів свою ефективність у спрощенні сигнатур методів та усуненні надлишковості. Видалення параметрів, значення яких можна отримати з внутрішнього стану об'єкта, робить код чистішим, а виклики методів — більш лаконічними. Це не лише покращує читабельність, але й знижує ймовірність помилок, пов'язаних із передачею некоректних даних, та посилює згуртованість класу, оскільки його методи починають більше покладатися на власні дані.
     Загалом, результати роботи підтверджують, що систематичне та свідоме застосування методів рефакторингу є невід'ємною частиною якісної розробки програмного забезпечення на TypeScript. Вони дозволяють не лише покращити поточну структуру коду, але й закласти міцний фундамент для майбутнього розширення та підтримки, роблячи систему більш надійною, гнучкою та зрозумілою для всієї команди розробників.


     5 ВИКОРИСТАНІ ДЖЕРЕЛА
     1. Refactoring.Guru: Інтерактивний вебсайт з детальними описами, ілюстраціями та прикладами методів рефакторингу. URL: https://refactoring.guru/ (Дата звернення: 05.11.2025).
     2. Martin Fowler's Blog (martinfowler.com): Персональний сайт-блог Мартіна Фаулера, автора фундаментальної книги «Рефакторинг». Містить оригінальний каталог технік рефакторингу, включно з "Remove Setting Method" та "Hide Method", які є основою для даної роботи. URL: https://martinfowler.com/ (Дата звернення: 05.11.2025).
     3. Офіційна документація TypeScript: Першоджерело для розуміння ключових механізмів мови, таких як модифікатори доступу (private, public) та readonly, які є інструментальною базою для виконання розглянутих методів рефакторингу. URL: https://www.typescriptlang.org/docs/ (Дата звернення: 05.11.2025).
     4. Fowler, Martin. Refactoring: Improving the Design of Existing Code. Addison-Wesley Professional, 2-ге видання. — Класична праця, що детально описує теорію та практику рефакторингу, слугуючи теоретичною основою для аналізу методів, представлених у роботі. URL: https://surl.lt/ycyesw (Дата звернення: 05.11.2025).
     5. MDN Web Docs (Mozilla Developer Network): Авторитетний ресурс з вебтехнологій, що містить документацію по JavaScript та TypeScript. URL: https://developer.mozilla.org/ (Дата звернення: 05.11.2025).


ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://www.youtube.com/watch?v=-OfxQvcyIus 
Хронологічний опис відеозапису:
0:00 - Вступ та представлення
0:14 - Що таке рефакторинг та його мета
0:42 - Огляд трьох технік: Remove Settings method, Hide method, Remove parameter
1:04 - Метод 1: Remove Settings method (Призначення та проблема)
1:28 - Приклад проблеми: Публічний сеттер для незмінного поля (клас Order)
1:54 - Рішення: Видалення сеттера та використання readonly
2:25 - Метод 2: Hide method (Призначення та посилення інкапсуляції)
2:46 - Приклад проблеми: Публічні допоміжні методи (клас ReportGenerator)
3:16 - Рішення: Використання модифікатора доступу private
3:41 - Метод 3: Remove parameter (Призначення та усунення надлишковості)
4:00 - Приклад проблеми: Зайвий параметр у методі (клас User)
4:23 - Рішення: Спрощення сигнатури та використання даних класу (this)
4:46 - Загальні висновки: Підсумок переваг кожного методу
5:15 - Використані джерела


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний лист
Рисунок Б.2 – Вступ до рефакторингу

Рисунок Б.3 – Методи, що розглядаються
Рисунок Б.4 – Remove Setting Method

Рисунок Б.5 – Неконтрольована зміна стану
Рисунок Б.6 – Імутабельність за допомогою readonly

Рисунок Б.7 – Hide Method
Рисунок Б.8 – Перевантажений публічний інтерфейс

Рисунок Б.9 – Інкапсуляція за допомогою private
Рисунок Б.10 – Remove Parameter

Рисунок Б.11 – Надлишковий параметр

Рисунок Б.12 – Спрощена та логічна сигнатура

Рисунок Б.13 – Загальні висновки

Рисунок Б.14 – Використані джерела



ДОДАТОК В
Програмний код
Додаток В.1. Код до застосування методу “Remove Setting Method”
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract2/ark-pzpi-23-10-khodus-danylo-pract2/code-examples-refactoring-methods.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
// Проблема: Публічний сетер дозволяє змінювати важливе поле, яке має бути незмінним.
class Order {
    public orderId: string;
    public amount: number;

    constructor(orderId: string, amount: number) {
        this.orderId = orderId;
        this.amount = amount;
    }

    // Цей метод дозволяє будь-кому ззовні змінити ID замовлення, що є небезпечним.
    public setOrderId(newId: string): void {
        console.log(`Order ID змінено з ${this.orderId} на ${newId}`);
        this.orderId = newId;
    }
}

const myOrder = new Order("ID-123", 100);
myOrder.setOrderId("ID-999");
Додаток В.2. Код після застосування методу “Remove Setting Method”
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract2/ark-pzpi-23-10-khodus-danylo-pract2/code-examples-refactoring-methods.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
// Рішення: Видалити сетер і зробити поле доступним лише для читання.
class Order {
    public readonly orderId: string; // Модифікатор readonly
    public amount: number;

    constructor(orderId: string, amount: number) {
        // Значення присвоюється лише один раз у конструкторі.
        this.orderId = orderId;
        this.amount = amount;
    }
}

const myOrder = new Order("ID-123", 100);
// Тепер спроба змінити ID призведе до помилки компіляції:
// myOrder.orderId = "ID-999"; // Error: Cannot assign to 'orderId' because it is a read-only property.

Додаток В.3. Код до застосування методу “Hide Method”
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract2/ark-pzpi-23-10-khodus-danylo-pract2/code-examples-refactoring-methods.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
// Проблема: Допоміжні методи є публічними, що засмічує API класу.
class ReportGenerator {
    // Основний метод, призначений для зовнішнього використання.
    public generateReport(): string {
        const data = this.fetchDataFromDB();
        const formattedData = this.formatData(data);
        return `Звіт: ${formattedData}`;
    }

    // Цей метод є деталлю реалізації і не повинен викликатися ззовні.
    public fetchDataFromDB(): string {
        // ... 
        return "Необроблені дані";
    }

    // Цей метод також є внутрішнім.
    public formatData(data: string): string {
        // ... 
        return data.toUpperCase();
    }
}

const report = new ReportGenerator();
// Зовнішній код може викликати внутрішні методи, що є поганою практикою.
const rawData = report.fetchDataFromDB();
Додаток В.4. Код після застосування методу “Hide Method”
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract2/ark-pzpi-23-10-khodus-danylo-pract2/code-examples-refactoring-methods.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
// Рішення: Зробити допоміжні методи приватними.
class ReportGenerator {
    public generateReport(): string {
        const data = this.fetchDataFromDB();
        const formattedData = this.formatData(data);
        return `Звіт: ${formattedData}`;
    }

    // Метод тепер приватний і доступний лише всередині цього класу.
    private fetchDataFromDB(): string {
        // ... 
        return "Необроблені дані";
    }

    // Цей метод також приховано.
    private formatData(data: string): string {
        // ... 
        return data.toUpperCase();
    }
}

const report = new ReportGenerator();
report.generateReport();
// Тепер виклик внутрішніх методів ззовні призведе до помилки компіляції.
// const rawData = report.fetchDataFromDB(); 
// Error: Property 'fetchDataFromDB' is private.
Додаток В.5. Код до застосування методу “Remove Parameter”
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract2/ark-pzpi-23-10-khodus-danylo-pract2/code-examples-refactoring-methods.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
// Проблема: Метод приймає параметр, значення якого вже є у класі.
class User {
    public username: string;

    constructor(username: string) {
        this.username = username;
    }

    // Параметр `name` є надлишковим, оскільки це те саме, що `this.username`.
    public createWelcomeMessage(name: string): string {
        return `Ласкаво просимо, ${name}!`;
    }
}

const user = new User("Alice");
// Незручний виклик: доводиться передавати дані, які об'єкт вже має.
const message = user.createWelcomeMessage(user.username);
console.log(message);
Додаток В.5. Код після застосування методу “Remove Parameter”
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract2/ark-pzpi-23-10-khodus-danylo-pract2/code-examples-refactoring-methods.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
// Рішення: Видалити зайвий параметр і використовувати стан об'єкта.
class User {
    public username: string;

    constructor(username: string) {
        this.username = username;
    }

    // Метод тепер не приймає параметрів і використовує `this.username`.
    public createWelcomeMessage(): string {
        return `Ласкаво просимо, ${this.username}!`;
    }
}

const user = new User("Alice");
// Виклик став набагато простішим і логічнішим.
const message = user.createWelcomeMessage();
console.log(message);
2


