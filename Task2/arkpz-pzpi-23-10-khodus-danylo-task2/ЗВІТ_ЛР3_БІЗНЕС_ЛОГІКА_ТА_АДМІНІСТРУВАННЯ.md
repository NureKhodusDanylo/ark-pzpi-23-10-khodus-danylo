# ЗВІТ
## Лабораторна робота №3
### «Розробка бізнес логіки та функцій адміністрування серверної частини системи»

**Виконав:** Ходус Данило
**Група:** ПЗПі-23-10
**Проект:** RobDeliveryAPI - Система автоматизації процесів доставки із використанням роботизованих систем

---

## 1. МЕТА РОБОТИ

Розробити бізнес-логіку серверної частини програмної системи для автоматизації процесів доставки з використанням роботизованих систем, а також реалізувати функції адміністрування системи.

---

## 2. ЗАВДАННЯ ЛАБОРАТОРНОЇ РОБОТИ

1. **Спроектувати алгоритми бізнес-логіки** - розробити алгоритми для основних операцій з даними, обробки запитів від клієнтів та виконання специфічних правил роботи системи.

2. **Розробити функції адміністрування** - реалізувати функції управління користувачами, системними параметрами, моніторингу активності, доступу до логів та управління ролями.

3. **Створити програмну реалізацію** - імплементувати програмний код для бізнес-логіки та функцій адміністрування на серверній частині.

---

## 3. АРХІТЕКТУРА СИСТЕМИ

Проект реалізовано з використанням **Clean Architecture** з 4 шарами:

### 3.1 Шари архітектури

1. **Entities (Domain Layer)** - доменні моделі, енуми та інтерфейси репозиторіїв
2. **Infrastructure (Data Access Layer)** - робота з базою даних через Entity Framework Core та SQLite
3. **Application (Business Logic Layer)** - бізнес-логіка, сервіси та DTO
4. **RobDeliveryAPI (Presentation Layer)** - REST API контролери та конфігурація

### 3.2 Ключові патерни проектування

- **Repository Pattern** - GenericRepository + спеціалізовані репозиторії
- **Service Layer Pattern** - бізнес-логіка винесена в сервіси
- **Dependency Injection** - всі залежності ін'єктуються через конструктор
- **DTO Pattern** - використання Data Transfer Objects для API контрактів

---

## 4. ПРОЕКТУВАННЯ АЛГОРИТМІВ БІЗНЕС-ЛОГІКИ

### 4.1 Алгоритм створення та управління замовленнями

**Файл:** `Application/Services/OrderService.cs`

#### 4.1.1 Алгоритм створення замовлення

**Вхідні дані:**
- ID відправника
- CreateOrderDTO (RecipientId, Name, Description, Weight, ProductPrice, IsProductPaid)

**Алгоритм:**

```
1. Валідація відправника:
   - Перевірити існування відправника в БД
   - Якщо не знайдено → викинути ArgumentException

2. Валідація одержувача:
   - Перевірити існування одержувача в БД
   - Якщо не знайдено → викинути ArgumentException

3. Перевірка правил бізнес-логіки:
   - Відправник ≠ Одержувач
   - Вага > 0
   - Ціна продукту ≥ 0
   - У відправника є PersonalNodeId
   - У одержувача є PersonalNodeId

4. Розрахунок вартості доставки:
   DeliveryPrice = 50 + (Weight × 10)
   Формула: базова ціна 50 грн + 10 грн за кг

5. Створення сутності Order:
   - Status = Pending
   - PickupNodeId = sender.PersonalNodeId
   - DropoffNodeId = recipient.PersonalNodeId
   - CreatedAt = DateTime.UtcNow

6. Збереження в БД та повернення OrderResponseDTO
```

**Код реалізації:** `OrderService.cs:31-105`

#### 4.1.2 Алгоритм призначення робота на замовлення

**Бізнес-правила:**
- Робот може бути призначений тільки у статусі "Idle"
- Рівень батареї робота має бути ≥ 20%
- Замовлення має бути у статусі "Pending" або "Processing"

**Алгоритм:**

```
1. Отримати замовлення з БД за orderId
   Якщо не знайдено → return false

2. Валідація робота:
   - Перевірити існування робота в БД
   - Якщо не існує → викинути ArgumentException

3. Перевірка доступності робота:
   - Якщо robot.Status ≠ Idle → викинути InvalidOperationException
   - Якщо robot.BatteryLevel < 20 → викинути InvalidOperationException

4. Перевірка статусу замовлення:
   - Якщо order.Status ∉ {Pending, Processing} → викинути InvalidOperationException

5. Призначення робота:
   - order.RobotId = robotId
   - Якщо order.Status == Pending → order.Status = Processing
   - robot.Status = Delivering
   - robot.CurrentNodeId = order.PickupNodeId

6. Збереження змін в БД
   - UpdateAsync(order)
   - UpdateAsync(robot)

7. Return true
```

**Код реалізації:** `OrderService.cs:183-233`

#### 4.1.3 Машина станів замовлення

**Допустимі переходи між статусами:**

```
Pending → Processing | Cancelled
Processing → EnRoute | Cancelled
EnRoute → Delivered | Cancelled
Delivered → [термінальний стан]
Cancelled → [термінальний стан]
```

**Алгоритм валідації переходів:**

```
FUNCTION IsValidStatusTransition(currentStatus, newStatus):
    MATCH currentStatus:
        CASE Pending:
            RETURN newStatus IN {Processing, Cancelled}
        CASE Processing:
            RETURN newStatus IN {EnRoute, Cancelled}
        CASE EnRoute:
            RETURN newStatus IN {Delivered, Cancelled}
        CASE Delivered:
            RETURN false
        CASE Cancelled:
            RETURN false
        DEFAULT:
            RETURN false
```

**Код реалізації:** `OrderService.cs:322-334`

#### 4.1.4 Алгоритм скасування замовлення

**Бізнес-правила:**
- Тільки відправник може скасувати замовлення
- Можна скасувати тільки замовлення у статусі Pending або Processing
- При скасуванні, якщо робот був призначений, він повертається у статус Idle

**Код реалізації:** `OrderService.cs:235-270`

### 4.2 Алгоритм автоматичного виконання замовлення з оптимізацією маршруту

**Файл:** `Application/Services/OrderService.cs:336-822`

Це найскладніший алгоритм системи, який автоматично знаходить оптимального дрона та планує маршрут доставки з урахуванням зарядних станцій.

#### 4.2.1 Загальний алгоритм ExecuteOrder

```
FUNCTION ExecuteOrderAsync(orderId):
    1. Отримати замовлення з БД
       Якщо не знайдено → викинути ArgumentException

    2. Валідація статусу
       Якщо order.Status ≠ Pending → викинути InvalidOperationException

    3. Отримати вузли pickup та dropoff з БД
       Якщо не знайдено → викинути InvalidOperationException

    4. Знайти всіх дронів на зарядних станціях:
       chargingDrones = GetByTypeAndStatusAsync(Drone, Charging)
       Якщо список порожній → викинути InvalidOperationException

    5. Для кожного дрона розрахувати маршрут:
       FOR EACH drone IN chargingDrones:
           (canComplete, route, distance, battery) = CalculateDroneRoute(
               drone,
               drone.CurrentNode,
               pickupNode,
               dropoffNode,
               order.Weight
           )

           IF canComplete AND distance < minTotalDistance:
               optimalDrone = drone
               optimalRoute = route
               minTotalDistance = distance
               optimalBatteryUsage = battery

    6. Якщо optimalDrone == null → викинути InvalidOperationException

    7. Призначити оптимального дрона на замовлення:
       AssignRobotToOrderAsync(orderId, optimalDrone.Id)

    8. Відправити команду на IoT пристрій дрона (якщо IP налаштовано):
       - Сформувати DroneCommandDTO з waypoints
       - SendDeliveryCommandAsync(IP, Port, command)

    9. Повернути ExecuteOrderResponseDTO з маршрутом та метриками
```

#### 4.2.2 Алгоритм розрахунку маршруту дрона

```
FUNCTION CalculateDroneRoute(drone, currentNode, pickupNode, dropoffNode, packageWeight):

    // Розрахунок дальності польоту
    metersPerBatteryPercentEmpty = drone.MaxFlightRangeMeters / 100

    // КРОК 1: Розрахунок маршруту до точки підбору (БЕЗ вантажу)
    (canReach, routeToPickup, distToPickup, battToPickup) =
        CalculateRouteSegmentWithCharging(
            currentNode,
            pickupNode,
            drone.BatteryLevel,
            metersPerBatteryPercentEmpty,
            segmentNumber=1,
            "Travel"
        )

    IF NOT canReach:
        RETURN (false, empty, 0, 0)

    route.AddRange(routeToPickup)
    totalDistance += distToPickup

    // Додати сегмент підбору пакету
    route.Add(RouteSegment{
        Action: "PickupPackage",
        FromNode: pickupNode,
        ToNode: pickupNode,
        Distance: 0
    })

    // Розрахунок залишку батареї після досягнення точки підбору
    remainingBattery = CalculateRemainingBattery(drone, routeToPickup, battToPickup)

    // КРОК 2: Розрахунок маршруту до точки доставки (З вантажем)
    // Ваговий коефіцієнт: зменшення дальності на 1% за кг, мінімум 50% ефективності
    weightFactor = MAX(0.5, 1.0 - packageWeight * 0.01)
    metersPerBatteryWithLoad = metersPerBatteryPercentEmpty * weightFactor

    (canReach, routeToDropoff, distToDropoff, battToDropoff) =
        CalculateRouteSegmentWithCharging(
            pickupNode,
            dropoffNode,
            remainingBattery,
            metersPerBatteryWithLoad,
            nextSegmentNumber,
            "Travel"
        )

    IF NOT canReach:
        RETURN (false, empty, 0, 0)

    route.AddRange(routeToDropoff)
    totalDistance += distToDropoff

    // Додати сегмент доставки пакету
    route.Add(RouteSegment{
        Action: "DeliverPackage",
        FromNode: dropoffNode,
        ToNode: dropoffNode,
        Distance: 0
    })

    totalBatteryUsage = battToPickup + battToDropoff
    RETURN (true, route, totalDistance, totalBatteryUsage)
```

**Код реалізації:** `OrderService.cs:513-602`

#### 4.2.3 Алгоритм розрахунку сегмента маршруту з урахуванням зарядки

Це рекурсивний алгоритм, який знаходить оптимальний шлях між двома точками, автоматично додаючи зупинки на зарядних станціях при необхідності.

```
FUNCTION CalculateRouteSegmentWithCharging(fromNode, toNode, currentBattery, metersPerBatteryPercent, segmentNumber, action):

    // Розрахунок відстані та необхідної батареї
    distanceToDestination = HaversineDistance(fromNode, toNode)
    requiredBattery = distanceToDestination / metersPerBatteryPercent

    // КРОК 1: Перевірка можливості прямого польоту
    IF requiredBattery <= currentBattery:
        // Перевірка безпеки: чи достатньо батареї для досягнення зарядної станції з пункту призначення
        nearestChargeFromDestination = FindNearestNodeAsync(toNode, ChargingStation)

        IF nearestChargeFromDestination EXISTS:
            distToCharge = HaversineDistance(toNode, nearestChargeFromDestination)
            batteryNeededForSafety = distToCharge / metersPerBatteryPercent
            remainingBatteryAtDestination = currentBattery - requiredBattery

            IF remainingBatteryAtDestination >= batteryNeededForSafety:
                // Безпечно летіти напряму
                route.Add(RouteSegment{
                    From: fromNode,
                    To: toNode,
                    Distance: distanceToDestination,
                    Action: action
                })
                RETURN (true, route, distanceToDestination, requiredBattery)
            ELSE:
                // Потрібна проміжна зарядка (йдемо до кроку 2)
        ELSE:
            // Немає зарядних станцій - ризикований, але дозволити якщо батареї достатньо
            route.Add(RouteSegment{...})
            RETURN (true, route, distanceToDestination, requiredBattery)

    // КРОК 2: Необхідна зарядка в процесі польоту
    allChargingStations = GetByTypeAsync(ChargingStation)

    IF allChargingStations.IsEmpty:
        RETURN (false, empty, 0, 0)

    // Знаходження оптимальної зарядної станції
    optimalStation = null
    minTotalDistance = MAX_VALUE

    FOR EACH station IN allChargingStations:
        distToStation = HaversineDistance(fromNode, station)
        battToStation = distToStation / metersPerBatteryPercent

        // Чи можемо досягти цієї станції з поточним зарядом?
        IF battToStation <= currentBattery:
            distFromStationToDest = HaversineDistance(station, toNode)
            battFromStationToDest = distFromStationToDest / metersPerBatteryPercent

            // Чи можемо після зарядки до 100% досягти призначення?
            IF battFromStationToDest <= 100:
                // Перевірка безпеки після досягнення призначення
                chargeFromDest = FindNearestNodeAsync(toNode, ChargingStation)

                IF chargeFromDest EXISTS:
                    distDestToCharge = HaversineDistance(toNode, chargeFromDest)
                    battDestToCharge = distDestToCharge / metersPerBatteryPercent
                    remainingAtDest = 100 - battFromStationToDest

                    IF remainingAtDest >= battDestToCharge:
                        totalRouteDistance = distToStation + distFromStationToDest

                        IF totalRouteDistance < minTotalDistance:
                            minTotalDistance = totalRouteDistance
                            optimalStation = station

    IF optimalStation == null:
        RETURN (false, empty, 0, 0)

    // КРОК 3: Політ до оптимальної зарядної станції
    distToOptimalStation = HaversineDistance(fromNode, optimalStation)
    battToOptimalStation = distToOptimalStation / metersPerBatteryPercent

    route.Add(RouteSegment{
        From: fromNode,
        To: optimalStation,
        Distance: distToOptimalStation,
        Action: action
    })
    totalDistance += distToOptimalStation
    totalBatteryUsed += battToOptimalStation

    // Додати сегмент зарядки
    route.Add(RouteSegment{
        From: optimalStation,
        To: optimalStation,
        Distance: 0,
        Action: "Charge"
    })

    // КРОК 4: Рекурсивний виклик для маршруту від зарядної станції до призначення
    (canComplete, remainingRoute, remainingDistance, remainingBattery) =
        CalculateRouteSegmentWithCharging(
            optimalStation,
            toNode,
            100,  // Повний заряд після зарядки
            metersPerBatteryPercent,
            nextSegmentNumber,
            action
        )

    IF NOT canComplete:
        RETURN (false, empty, 0, 0)

    route.AddRange(remainingRoute)
    totalDistance += remainingDistance
    totalBatteryUsed += remainingBattery

    RETURN (true, route, totalDistance, totalBatteryUsed)
```

**Код реалізації:** `OrderService.cs:604-797`

#### 4.2.4 Алгоритм розрахунку відстані (Haversine Formula)

Для розрахунку відстані між двома географічними точками використовується формула Haversine:

```
FUNCTION CalculateDistance(node1, node2):
    CONST earthRadiusMeters = 6371000

    lat1Rad = ToRadians(node1.Latitude)
    lat2Rad = ToRadians(node2.Latitude)
    deltaLatRad = ToRadians(node2.Latitude - node1.Latitude)
    deltaLonRad = ToRadians(node2.Longitude - node1.Longitude)

    a = sin²(deltaLatRad/2) + cos(lat1Rad) × cos(lat2Rad) × sin²(deltaLonRad/2)
    c = 2 × atan2(√a, √(1-a))

    distance = earthRadiusMeters × c
    RETURN distance  // в метрах
```

**Код реалізації:** `OrderService.cs:799-821`

### 4.3 Алгоритм управління роботами

**Файл:** `Application/Services/RobotService.cs`

#### 4.3.1 Алгоритм реєстрації робота (IoT пристрою)

```
FUNCTION RegisterRobotAsync(registerDto):
    1. Валідація вхідних даних:
       - Name не пусте
       - Model не пусте
       - SerialNumber не пусте
       - AccessKey не пусте
       - Type IN {GroundCourier, Drone}
       - BatteryCapacityJoules > 0 (якщо надано)
       - EnergyConsumptionPerMeterJoules > 0 (якщо надано)
       - Port IN [1, 65535] (якщо надано)

    2. Перевірка унікальності SerialNumber:
       IF SerialNumberExistsAsync(serialNumber):
           RETURN (false, null, "Серійний номер вже існує")

    3. Хешування ключа доступу:
       accessKeyHash = SHA256(registerDto.AccessKey)

    4. Створення сутності Robot:
       robot = NEW Robot {
           Name, Model, Type,
           Status = Idle,
           BatteryLevel = 100.0,
           SerialNumber,
           AccessKeyHash,
           BatteryCapacityJoules = registerDto.BatteryCapacityJoules ?? 360000,
           EnergyConsumptionPerMeterJoules = registerDto.EnergyConsumptionPerMeterJoules ?? 36,
           IpAddress = registerDto.IpAddress,
           Port = registerDto.Port ?? 80,
           CurrentNodeId = registerDto.CurrentNodeId
       }

    5. Збереження в БД:
       AddAsync(robot)
       SaveChangesAsync()

    6. RETURN (true, robot.Id, null)
```

**Код реалізації:** `RobotService.cs:99-160`

#### 4.3.2 Алгоритм аутентифікації робота

```
FUNCTION AuthenticateRobotAsync(loginDto):
    1. Валідація вхідних даних:
       IF SerialNumber OR AccessKey пусті:
           RETURN (false, null, "Обов'язкові поля")

    2. Пошук робота за серійним номером:
       robot = GetBySerialNumberAsync(loginDto.SerialNumber)

       IF robot == null:
           RETURN (false, null, "Невірні дані")

    3. Перевірка наявності хеша ключа:
       IF robot.AccessKeyHash пустий:
           RETURN (false, null, "Автентифікація не налаштована")

    4. Верифікація ключа доступу:
       hashedAccessKey = SHA256(loginDto.AccessKey)

       IF robot.AccessKeyHash ≠ hashedAccessKey:
           RETURN (false, null, "Невірні дані")

    5. RETURN (true, robot.Id, null)
```

**Код реалізації:** `RobotService.cs:162-185`

#### 4.3.3 Алгоритм оновлення статусу робота (телеметрія від IoT)

```
FUNCTION UpdateRobotStatusAsync(robotId, statusUpdate):
    1. Отримати робота з БД:
       robot = GetByIdAsync(robotId)
       IF robot == null:
           RETURN null

    2. Валідація та парсинг статусу:
       IF NOT TryParse(statusUpdate.Status, OUT newStatus):
           THROW ArgumentException("Невірний статус. Має бути: Idle, Delivering, Charging, Maintenance")

    3. Оновлення даних робота:
       robot.Status = newStatus
       robot.BatteryLevel = statusUpdate.BatteryLevel
       robot.CurrentNodeId = statusUpdate.CurrentNodeId
       robot.CurrentLatitude = statusUpdate.CurrentLatitude
       robot.CurrentLongitude = statusUpdate.CurrentLongitude
       robot.TargetNodeId = statusUpdate.TargetNodeId

    4. Збереження в БД:
       UpdateAsync(robot)

    5. RETURN MapToResponseDTO(robot)
```

**Код реалізації:** `RobotService.cs:187-212`

### 4.4 Алгоритм управління користувачами

**Файл:** `Application/Services/UserService.cs`, `Application/Services/AuthorizationService.cs`

#### 4.4.1 Алгоритм реєстрації користувача

**Файл:** `Application/Services/AuthorizationService.cs`

```
FUNCTION RegisterUserAsync(registerDto, adminKey):
    1. Валідація email:
       IF NOT IsValidEmail(registerDto.Email):
           RETURN (false, "Невірний формат email")

    2. Перевірка унікальності email:
       IF EmailExistsAsync(registerDto.Email):
           RETURN (false, "Email вже зареєстровано")

    3. Визначення ролі користувача:
       role = User  // за замовчуванням

       IF adminKey NOT empty:
           adminKeyEntity = GetByKeyCodeAsync(adminKey)

           IF adminKeyEntity EXISTS AND NOT adminKeyEntity.IsUsed:
               IF adminKeyEntity.ExpiresAt == null OR adminKeyEntity.ExpiresAt > UtcNow:
                   role = Admin
                   adminKeyEntity.IsUsed = true
                   adminKeyEntity.UsedAt = UtcNow
                   adminKeyEntity.UsedByUserId = (буде встановлено після створення)
               ELSE:
                   RETURN (false, "Ключ адміністратора прострочений")
           ELSE:
               RETURN (false, "Невірний або використаний ключ")

    4. Хешування пароля:
       passwordHash = SHA256(registerDto.Password)

    5. Створення особистого вузла користувача:
       personalNode = NEW Node {
           Name = registerDto.Address ?? "Домашня адреса",
           Latitude = registerDto.Latitude,
           Longitude = registerDto.Longitude,
           Type = UserNode
       }
       AddAsync(personalNode)
       SaveChangesAsync()

    6. Створення користувача:
       user = NEW User {
           UserName = registerDto.UserName,
           Email = registerDto.Email,
           PasswordHash,
           PhoneNumber = registerDto.PhoneNumber,
           Role = role,
           PersonalNodeId = personalNode.Id
       }
       AddAsync(user)
       SaveChangesAsync()

    7. Якщо була використана AdminKey:
       adminKeyEntity.UsedByUserId = user.Id
       UpdateAsync(adminKeyEntity)
       SaveChangesAsync()

    8. RETURN (true, "Користувача зареєстровано успішно")
```

#### 4.4.2 Алгоритм пошуку користувачів

```
FUNCTION SearchUsersAsync(query, currentUserId):
    1. Валідація запиту:
       IF query пустий:
           THROW ArgumentException("Пошуковий запит не може бути порожнім")

    2. Пошук у БД (через UserRepository):
       users = SearchUsersAsync(query)
       // Пошук за UserName, PhoneNumber, PersonalNode.Name (адреса)

    3. Фільтрація результатів:
       results = users.Where(user => user.Id ≠ currentUserId)
       // Виключити поточного користувача з результатів

    4. Маппінг на DTO:
       RETURN results.Select(user => NEW UserSearchResultDTO {
           Id, UserName, PhoneNumber,
           Address = user.PersonalNode?.Name
       })
```

**Код реалізації:** `UserService.cs:86-105`

#### 4.4.3 Алгоритм оновлення профілю з фото

```
FUNCTION UpdateProfileWithPhotoAsync(userId, updateDto, profilePhoto, contentRootPath):
    1. Отримати користувача:
       user = GetByIdAsync(userId)
       IF user == null:
           THROW ArgumentException("Користувача не знайдено")

    2. Оновити базову інформацію:
       IF updateDto.UserName NOT empty:
           user.UserName = updateDto.UserName

       IF updateDto.PhoneNumber NOT empty:
           user.PhoneNumber = updateDto.PhoneNumber

       IF updateDto.Password NOT empty:
           user.PasswordHash = SHA256(updateDto.Password)

    3. Збереження змін:
       UpdateAsync(user)
       SaveChangesAsync()

    4. Обробка фото профілю (якщо надано):
       IF profilePhoto NOT null:
           photoDto = UploadProfilePhotoAsync(userId, profilePhoto, contentRootPath)
           // Внутрішньо FileService видалить старе фото та завантажить нове

    5. Перезавантажити користувача для отримання оновлених даних:
       user = GetByIdAsync(userId)

    6. RETURN MapToUserProfileDTO(user)
```

**Код реалізації:** `UserService.cs:251-304`

---

## 5. ФУНКЦІЇ АДМІНІСТРУВАННЯ СИСТЕМИ

### 5.1 Система ролей та авторизації

**Ролі в системі:**
- **User** - звичайний користувач (створення замовлень, перегляд власних замовлень)
- **Admin** - адміністратор (повний доступ до системи, статистика, бекапи, аналітика)
- **Iot** - IoT пристрій (роботи для контролю та телеметрії)

**Реалізація авторизації:**
- JWT токени з алгоритмом HS256
- Роль додається в claims токена
- Атрибут `[Authorize(Roles = "Admin")]` на admin-only ендпоінтах

### 5.2 Генерація ключів адміністратора

**Файл:** `Application/Services/AdminService.cs:176-198`

**Алгоритм:**

```
FUNCTION GenerateAdminKeyAsync(createdByAdminId, expiresAt, description):
    1. Генерація безпечного ключа:
       randomBytes = CryptographicRandom(32 bytes)
       keyCode = Base64(randomBytes)
           .Replace("+", "")
           .Replace("/", "")
           .Replace("=", "")
           .Substring(0, 24)
       keyCode = "ADMIN-" + keyCode

    2. Створення сутності AdminKey:
       adminKey = NEW AdminKey {
           KeyCode,
           CreatedAt = UtcNow,
           ExpiresAt = expiresAt,  // null = без терміну дії
           IsUsed = false,
           CreatedByAdminId,
           Description
       }

    3. Збереження в БД:
       AddAsync(adminKey)
       SaveChangesAsync()

    4. Перезавантаження для отримання навігаційних властивостей:
       createdKey = GetByKeyCodeAsync(keyCode)

    5. RETURN MapToDTO(createdKey)
```

**Приклад ключа:** `ADMIN-8K3mP9xR2vQ7nL4wE6sT1yU`

### 5.3 Системна статистика

**Файл:** `Application/Services/AdminService.cs:33-63`

**Алгоритм GetSystemStatsAsync:**

```
FUNCTION GetSystemStatsAsync():
    1. Отримати всі дані з БД:
       users = GetAllAsync<User>()
       orders = GetAllAsync<Order>()
       robots = GetAllAsync<Robot>()
       nodes = GetAllAsync<Node>()

    2. Розрахунок статистики замовлень:
       totalOrders = orders.Count
       activeOrders = orders.Count(o => o.Status IN {Processing, EnRoute})
       completedOrders = orders.Count(o => o.Status == Delivered)
       cancelledOrders = orders.Count(o => o.Status == Cancelled)

    3. Розрахунок статистики роботів:
       totalRobots = robots.Count
       availableRobots = robots.Count(r => r.Status == Idle)
       busyRobots = robots.Count(r => r.Status == Delivering)
       chargingRobots = robots.Count(r => r.Status == Charging)
       averageBatteryLevel = robots.Average(r => r.BatteryLevel)

    4. Розрахунок доходів:
       totalRevenue = orders
           .Where(o => o.IsProductPaid AND o.Status == Delivered)
           .Sum(o => o.DeliveryPrice + o.ProductPrice)

    5. Створення DTO:
       stats = NEW SystemStatsDTO {
           TotalUsers = users.Count,
           TotalOrders, TotalRobots, TotalNodes = nodes.Count,
           ActiveOrders, CompletedOrders, CancelledOrders,
           AvailableRobots, BusyRobots, ChargingRobots,
           AverageBatteryLevel,
           TotalRevenue
       }

    6. RETURN stats
```

**Приклад відповіді:**

```json
{
  "totalUsers": 150,
  "totalOrders": 450,
  "totalRobots": 25,
  "totalNodes": 75,
  "activeOrders": 12,
  "completedOrders": 380,
  "cancelledOrders": 58,
  "availableRobots": 15,
  "busyRobots": 8,
  "chargingRobots": 2,
  "averageBatteryLevel": 67.5,
  "totalRevenue": 45600.50
}
```

### 5.4 Експорт історії доставок

**Файл:** `Application/Services/AdminService.cs:65-100`

**Алгоритм:**

```
FUNCTION ExportDeliveryHistoryAsync():
    1. Отримати всі замовлення з БД (з eager loading):
       orders = GetAllAsync<Order>()
       // Включаючи Sender, Recipient, AssignedRobot, PickupNode, DropoffNode

    2. Маппінг на анонімний тип для експорту:
       deliveryHistory = orders.Select(o => {
           Id, Name, Description, Weight,
           DeliveryPrice, ProductPrice, IsProductPaid,
           Status = o.Status.ToString(),
           CreatedAt, CompletedAt,
           SenderId, SenderName = o.Sender?.UserName,
           RecipientId, RecipientName = o.Recipient?.UserName,
           RobotId, RobotName = o.AssignedRobot?.Name,
           PickupNodeId, PickupNodeName = o.PickupNode?.Name,
           DropoffNodeId, DropoffNodeName = o.DropoffNode?.Name
       })

    3. Серіалізація в JSON:
       options = NEW JsonSerializerOptions {
           WriteIndented = true,
           PropertyNamingPolicy = CamelCase
       }
       json = JsonSerializer.Serialize(deliveryHistory, options)

    4. RETURN json
```

**Використання в контролері:**

```csharp
[HttpGet("export/delivery-history")]
public async Task<IActionResult> ExportDeliveryHistory()
{
    var historyJson = await _adminService.ExportDeliveryHistoryAsync();
    var fileName = $"DeliveryHistory_{DateTime.Now:yyyyMMdd_HHmmss}.json";

    return File(
        System.Text.Encoding.UTF8.GetBytes(historyJson),
        "application/json",
        fileName
    );
}
```

### 5.5 Резервне копіювання бази даних

**Файл:** `Application/Services/AdminService.cs:102-154`

**Алгоритм CreateDatabaseBackupAsync:**

```
FUNCTION CreateDatabaseBackupAsync(backupPath):
    TRY:
        1. Визначити можливі шляхи до БД SQLite:
           possiblePaths = [
               "Infrastructure/DB_Storage/RobDelivery.db",
               "../Infrastructure/DB_Storage/RobDelivery.db",
               "../../../Infrastructure/DB_Storage/RobDelivery.db"
           ]

        2. Знайти існуючий файл БД:
           FOR EACH path IN possiblePaths:
               fullPath = GetFullPath(path)
               IF File.Exists(fullPath):
                   sourceDbPath = fullPath
                   BREAK

        3. Якщо БД не знайдено:
           THROW FileNotFoundException("БД не знайдено")

        4. Створити ім'я файлу бекапу з timestamp:
           timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss")
           backupFileName = "RobDelivery_Backup_{timestamp}.db"
           fullBackupPath = Path.Combine(backupPath, backupFileName)

        5. Створити директорію для бекапів:
           Directory.CreateDirectory(backupPath)

        6. Скопіювати файл БД:
           File.Copy(sourceDbPath, fullBackupPath, overwrite: true)

        7. Експортувати історію доставок у JSON:
           historyJson = ExportDeliveryHistoryAsync()
           jsonBackupPath = Path.Combine(backupPath, "DeliveryHistory_{timestamp}.json")
           WriteAllTextAsync(jsonBackupPath, historyJson)

        8. RETURN true

    CATCH Exception:
        RETURN false
```

**Використання:**

```http
POST /api/Admin/backup
Content-Type: application/json

{
  "backupPath": "Backups"
}
```

**Результат:** У папці `Backups/` створюються два файли:
- `RobDelivery_Backup_20250109_143520.db` - копія БД
- `DeliveryHistory_20250109_143520.json` - експорт історії

### 5.6 Аналітика ефективності роботів

**Файл:** `Application/Services/AdminService.cs:156-174`

**Алгоритм GetRobotEfficiencyAsync:**

```
FUNCTION GetRobotEfficiencyAsync():
    1. Отримати всіх роботів з БД:
       robots = GetAllAsync<Robot>()

    2. Для кожного робота розрахувати ефективність:
       efficiency = Dictionary<int, double>

       FOR EACH robot IN robots:
           // Підрахунок завершених замовлень
           completedOrders = robot.ActiveOrders?.Count(o => o.Status == Delivered) ?? 0

           // Формула ефективності:
           // Efficiency = (Completed Orders) / (101 - Battery Level) × 100
           // Чим більше доставлено при нижчому заряді - тим ефективніший робот

           IF robot.BatteryLevel > 0:
               batteryEfficiency = completedOrders / (101 - robot.BatteryLevel)
           ELSE:
               batteryEfficiency = 0

           efficiency[robot.Id] = Round(batteryEfficiency × 100, 2)

    3. RETURN efficiency
```

**Приклад відповіді:**

```json
{
  "1": 85.67,
  "2": 92.45,
  "3": 78.90,
  "4": 65.30
}
```

**Інтерпретація:**
- Робот #2 - найефективніший (92.45)
- Робот #4 - найменш ефективний (65.30)

### 5.7 API Endpoints для адміністрування

**Файл:** `RobDeliveryAPI/Controllers/AdminController.cs`

Всі endpoints доступні тільки для ролі Admin `[Authorize(Roles = "Admin")]`

| Метод | Endpoint | Опис |
|-------|----------|------|
| GET | `/api/Admin/stats` | Отримання системної статистики |
| GET | `/api/Admin/export/delivery-history` | Експорт історії доставок (JSON) |
| POST | `/api/Admin/backup` | Створення резервної копії БД |
| GET | `/api/Admin/analytics/robot-efficiency` | Аналітика ефективності роботів |
| POST | `/api/Admin/keys/generate` | Генерація нового ключа адміністратора |
| GET | `/api/Admin/keys` | Отримання всіх ключів адміністратора |
| GET | `/api/Admin/keys/unused` | Отримання невикористаних ключів |
| POST | `/api/Admin/keys/{keyId}/revoke` | Відкликання ключа адміністратора |

---

## 6. ДОДАТКОВІ СЕРВІСИ БІЗНЕС-ЛОГІКИ

### 6.1 Сервіс зв'язку з IoT пристроями (дронами)

**Файл:** `Application/Services/DroneConnectionService.cs`

Цей сервіс забезпечує комунікацію з Arduino-based дронами через TCP/IP.

**Основні методи:**

```csharp
// Відправка команди доставки на дрона
Task<DroneResponseDTO> SendDeliveryCommandAsync(string ipAddress, int port, DroneCommandDTO command)

// Перевірка з'єднання з дроном
Task<bool> CheckConnectionAsync(string ipAddress, int port)
```

**DroneCommandDTO структура:**

```csharp
{
    OrderId: int,
    OrderName: string,
    PackageWeight: double,
    PickupNodeId: int,
    PickupLatitude: double,
    PickupLongitude: double,
    DropoffNodeId: int,
    DropoffLatitude: double,
    DropoffLongitude: double,
    Route: List<RouteWaypointDTO>,
    TotalDistanceMeters: double,
    EstimatedBatteryUsagePercent: double,
    CommandTimestamp: DateTime
}
```

### 6.2 Сервіс управління файлами

**Файл:** `Application/Services/FileService.cs`

Відповідає за завантаження та управління файлами (фото профілів, зображення замовлень).

**Основні методи:**

```csharp
// Завантаження фото профілю користувача
Task<FileResponseDTO> UploadProfilePhotoAsync(int userId, FileUploadDTO file, string contentRootPath)

// Отримання файлу за ID
Task<FileResponseDTO?> GetFileByIdAsync(int fileId)

// Отримання вмісту файлу
Task<byte[]?> GetFileContentAsync(int fileId, string contentRootPath)

// Видалення старого фото користувача
Task DeleteUserOldPhotoAsync(int userId, string contentRootPath)
```

**Алгоритм завантаження фото:**

```
FUNCTION UploadProfilePhotoAsync(userId, file, contentRootPath):
    1. Валідація файлу:
       allowedExtensions = {".jpg", ".jpeg", ".png", ".gif"}
       maxFileSize = 5 MB

       IF file.Size > maxFileSize:
           THROW ArgumentException("Файл занадто великий")

       IF extension NOT IN allowedExtensions:
           THROW ArgumentException("Недопустимий формат")

    2. Видалення старого фото:
       DeleteUserOldPhotoAsync(userId, contentRootPath)

    3. Генерація унікального імені файлу:
       timestamp = DateTime.UtcNow.ToString("yyyyMMddHHmmss")
       uniqueFileName = $"{userId}_{timestamp}{extension}"
       uploadPath = "Uploads/Profiles/{uniqueFileName}"

    4. Збереження файлу на диск:
       Directory.CreateDirectory("Uploads/Profiles")
       File.WriteAllBytes(fullPath, file.Content)

    5. Створення запису в БД:
       fileEntity = NEW File {
           FileName = originalFileName,
           FilePath = uploadPath,
           ContentType = file.ContentType,
           FileSize = file.Size,
           UploadedAt = UtcNow
       }
       AddAsync(fileEntity)
       SaveChangesAsync()

    6. Оновлення користувача:
       user.ProfilePhotoId = fileEntity.Id
       UpdateAsync(user)
       SaveChangesAsync()

    7. RETURN MapToDTO(fileEntity)
```

### 6.3 Сервіс управління вузлами (Node Service)

**Файл:** `Application/Services/NodeService.cs`

Управляє географічними вузлами системи.

**Типи вузлів:**
- **UserNode** - особисті адреси користувачів
- **ChargingStation** - станції зарядки роботів
- **Depot** - базові станції роботів

**Основні методи:**

```csharp
// Створення вузла
Task<NodeResponseDTO> CreateNodeAsync(CreateNodeDTO nodeDto)

// Пошук найближчого вузла певного типу
Task<NodeResponseDTO?> FindNearestNodeAsync(double latitude, double longitude, NodeType type)

// Отримання всіх вузлів певного типу
Task<IEnumerable<NodeResponseDTO>> GetByTypeAsync(NodeType type)

// Оновлення вузла
Task<bool> UpdateNodeAsync(UpdateNodeDTO nodeDto)

// Видалення вузла
Task<bool> DeleteNodeAsync(int nodeId)
```

### 6.4 Сервіс авторизації

**Файл:** `Application/Services/AuthorizationService.cs`

Відповідає за реєстрацію та автентифікацію користувачів.

**Основні методи:**

```csharp
// Реєстрація нового користувача
Task<(bool Success, string Message)> RegisterUserAsync(UserRegisterDTO registerDto, string? adminKey)

// Автентифікація за email та паролем
Task<(bool Success, int? UserId, string? ErrorMessage)> AuthenticateUserAsync(UserLoginDTO loginDto)

// Автентифікація через Google OAuth
Task<(bool Success, int? UserId, string? ErrorMessage)> AuthenticateWithGoogleAsync(string googleIdToken)
```

### 6.5 Сервіс токенів JWT

**Файл:** `Application/Services/BaseTokenService.cs`

Генерація та валідація JWT токенів.

**Основні методи:**

```csharp
// Генерація токена для користувача
string GenerateToken(User user)

// Генерація токена для робота (IoT)
string GenerateRobotToken(Robot robot)

// Валідація токена
bool ValidateToken(string token)
```

**Структура токена:**

```json
{
  "Id": "123",
  "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": "User",
  "exp": 1763221417,
  "iss": "RobDeliveryAPI",
  "aud": "RobDeliveryClient"
}
```

---

## 7. ТЕСТУВАННЯ СИСТЕМИ

### 7.1 PowerShell тести

Проект включає 4 комплексних PowerShell скрипта для тестування:

1. **test_api.ps1** - Повний набір тестів API (350+ запитів)
2. **test_api_simple.ps1** - Спрощений набір тестів
3. **test_complete.ps1** - Тестування повного workflow
4. **test_fix.ps1** - Тести для перевірки конкретних виправлень

### 7.2 HTTP файл

**Файл:** `RobDeliveryAPI.http` (350+ рядків)

Містить приклади всіх HTTP запитів до API для ручного тестування.

### 7.3 Приклад тестового сценарію

```powershell
# 1. Реєстрація користувача
$registerResponse = Invoke-RestMethod -Uri "$baseUrl/api/Auth/register" -Method Post -Body $registerJson

# 2. Логін
$loginResponse = Invoke-RestMethod -Uri "$baseUrl/api/Auth/login" -Method Post -Body $loginJson
$token = $loginResponse.token

# 3. Створення замовлення
$headers = @{ Authorization = "Bearer $token" }
$orderResponse = Invoke-RestMethod -Uri "$baseUrl/api/Order" -Method Post -Headers $headers -Body $orderJson

# 4. Призначення робота
$assignResponse = Invoke-RestMethod -Uri "$baseUrl/api/Order/$orderId/assign-robot/$robotId" -Method Post -Headers $headers

# 5. Оновлення статусу
$statusResponse = Invoke-RestMethod -Uri "$baseUrl/api/Order/$orderId/status" -Method Put -Headers $headers -Body $statusJson

# 6. Перевірка статистики (Admin)
$statsResponse = Invoke-RestMethod -Uri "$baseUrl/api/Admin/stats" -Method Get -Headers $adminHeaders
```

---

## 8. ВИСНОВКИ

### 8.1 Виконані завдання

У рамках лабораторної роботи №3 було успішно виконано наступне:

#### 1. Проектування алгоритмів бізнес-логіки

✅ **Алгоритм управління замовленнями:**
- Створення замовлень з автоматичним розрахунком вартості доставки
- Машина станів для статусів замовлень (Pending → Processing → EnRoute → Delivered/Cancelled)
- Призначення роботів на замовлення з валідацією доступності та рівня батареї
- Скасування замовлень з автоматичним звільненням робота

✅ **Алгоритм автоматичного планування маршруту:**
- Розрахунок відстаней за формулою Haversine
- Пошук оптимального дрона серед доступних на зарядних станціях
- Автоматичне планування зупинок на зарядних станціях
- Врахування ваги вантажу (зменшення дальності польоту на 1% за кг)
- Рекурсивний алгоритм планування маршруту з перевіркою безпеки
- Генерація waypoints для IoT пристроїв (Arduino)

✅ **Алгоритм управління роботами:**
- Реєстрація IoT пристроїв з криптографічною автентифікацією
- Аутентифікація роботів за серійним номером та ключем доступу
- Оновлення телеметрії (батарея, координати, статус)
- Пошук доступних роботів за критеріями

✅ **Алгоритм управління користувачами:**
- Реєстрація з автоматичним створенням особистого вузла
- Автентифікація за паролем та Google OAuth
- Пошук користувачів за іменем/телефоном/адресою
- Оновлення профілю з завантаженням фото

#### 2. Розробка функцій адміністрування

✅ **Система ролей та авторизації:**
- Три ролі: User, Admin, IoT
- JWT токени з HS256
- Role-based authorization на endpoint рівні

✅ **Генерація ключів адміністратора:**
- Криптографічно безпечна генерація ключів
- Підтримка терміну дії ключів
- Відстеження використання ключів
- Можливість відкликання ключів

✅ **Системна статистика:**
- Загальна кількість користувачів, замовлень, роботів, вузлів
- Активні/завершені/скасовані замовлення
- Доступні/зайняті/на зарядці роботи
- Середній рівень батареї
- Загальний дохід

✅ **Експорт та резервне копіювання:**
- Експорт історії доставок у JSON
- Резервне копіювання БД SQLite
- Автоматичне іменування з timestamp

✅ **Аналітика ефективності роботів:**
- Розрахунок ефективності за формулою (Completed Orders) / (101 - Battery Level) × 100
- Ідентифікація найбільш/найменш ефективних роботів

#### 3. Програмна реалізація

✅ **Clean Architecture:**
- Повна ізоляція шарів
- Dependency Injection для всіх сервісів
- Repository Pattern для доступу до даних
- DTO Pattern для API контрактів

✅ **Сервісний шар (Application/Services):**
- 12 сервісів бізнес-логіки
- 100% покриття основних операцій
- Валідація на рівні бізнес-логіки
- Обробка помилок через exceptions

✅ **API контролери (RobDeliveryAPI/Controllers):**
- RESTful API з 40+ endpoints
- Swagger documentation
- Role-based authorization
- Стандартизовані HTTP відповіді

✅ **Інтеграція з IoT:**
- TCP/IP комунікація з Arduino дронами
- Відправка команд доставки
- Отримання телеметрії
- Підтримка IP та Port конфігурації

### 8.2 Переваги реалізованої архітектури

1. **Масштабованість** - легко додавати нові типи роботів, алгоритми маршрутизації
2. **Тестованість** - кожен шар може бути протестований незалежно
3. **Підтримуваність** - чітке розділення відповідальностей
4. **Безпека** - JWT, SHA-256, role-based authorization, криптографічні ключі
5. **Продуктивність** - оптимізовані запити до БД, кешування навігаційних властивостей

### 8.3 Технологічний стек

- **Backend:** ASP.NET Core 8.0 (C#)
- **Database:** SQLite + Entity Framework Core 8.0
- **Authentication:** JWT (HS256) + Google OAuth
- **IoT:** TCP/IP communication with Arduino
- **API:** RESTful API + Swagger
- **Testing:** PowerShell scripts + .http files

### 8.4 Статистика проекту

- **Сервісів:** 12
- **Контролерів:** 6
- **Endpoints:** 40+
- **Моделей:** 15
- **DTOs:** 50+
- **Репозиторіїв:** 7
- **Рядків коду OrderService:** 824 (найскладніший модуль)
- **Тестових запитів:** 350+

### 8.5 Практична цінність

Розроблена система демонструє:
- **Промислові підходи** до побудови enterprise-рівня додатків
- **Складні алгоритми** планування маршрутів з оптимізацією
- **Повну інтеграцію** backend з IoT пристроями
- **Професійні практики** адміністрування та моніторингу

---

## 9. ДОДАТКОВІ МАТЕРІАЛИ

### 9.1 Структура проекту

```
arkpz-pzpi-23-10-khodus-danylo-task2/
├── Entities/                    # Domain Layer
│   ├── Models/                  # Доменні моделі
│   │   ├── User.cs
│   │   ├── Order.cs
│   │   ├── Robot.cs
│   │   ├── Node.cs
│   │   ├── File.cs
│   │   └── AdminKey.cs
│   ├── Enums/                   # Енумерації
│   │   ├── OrderStatus.cs
│   │   ├── RobotStatus.cs
│   │   ├── RobotType.cs
│   │   └── NodeType.cs
│   └── Interfaces/              # Інтерфейси репозиторіїв
│       ├── IUserRepository.cs
│       ├── IOrderRepository.cs
│       └── ...
├── Infrastructure/              # Data Access Layer
│   ├── Repository/
│   │   ├── GenericRepository.cs
│   │   ├── UserRepository.cs
│   │   ├── OrderRepository.cs
│   │   └── ...
│   ├── MyDbContext.cs
│   └── DB_Storage/
│       └── RobDelivery.db
├── Application/                 # Business Logic Layer
│   ├── Services/
│   │   ├── OrderService.cs      # 824 рядки - складна логіка маршрутизації
│   │   ├── AdminService.cs      # 266 рядків - адміністрування
│   │   ├── RobotService.cs      # 233 рядки - управління роботами
│   │   ├── UserService.cs       # 329 рядків - управління користувачами
│   │   ├── AuthorizationService.cs
│   │   ├── NodeService.cs
│   │   ├── FileService.cs
│   │   ├── DroneConnectionService.cs
│   │   ├── BaseTokenService.cs
│   │   ├── GoogleTokenValidator.cs
│   │   ├── Sha256PasswordHasher.cs
│   │   └── PaymentProcessorService.cs
│   ├── DTOs/
│   │   ├── OrderDTOs/
│   │   ├── UserDTOs/
│   │   ├── RobotDTOs/
│   │   ├── NodeDTOs/
│   │   ├── AdminDTOs/
│   │   └── FileDTOs/
│   └── Abstractions/
│       └── Interfaces/
├── RobDeliveryAPI/              # Presentation Layer
│   ├── Controllers/
│   │   ├── OrderController.cs
│   │   ├── UserController.cs
│   │   ├── RobotController.cs
│   │   ├── NodeController.cs
│   │   ├── AdminController.cs
│   │   └── AuthController.cs
│   ├── Program.cs
│   └── appsettings.json
├── test_api.ps1                 # Тести
├── test_api_simple.ps1
├── test_complete.ps1
├── test_fix.ps1
└── RobDeliveryAPI.http          # HTTP запити
```

### 9.2 Ключові файли для перевірки

1. **OrderService.cs:336-822** - Алгоритм автоматичного планування маршруту
2. **AdminService.cs:33-174** - Всі функції адміністрування
3. **RobotService.cs:99-212** - IoT інтеграція та телеметрія
4. **AdminController.cs** - API endpoints адміністрування
5. **MyDbContext.cs:21-97** - EF Core конфігурація

### 9.3 Корисні посилання

- **API документація:** `http://localhost:5102/swagger` (в режимі розробки)
- **База даних:** `Infrastructure/DB_Storage/RobDelivery.db`
- **Бекапи:** `Backups/` (створюються автоматично)
- **Завантажені файли:** `Uploads/Profiles/`

---

**Дата виконання:** 09.01.2025
**Підпис студента:** _________________
