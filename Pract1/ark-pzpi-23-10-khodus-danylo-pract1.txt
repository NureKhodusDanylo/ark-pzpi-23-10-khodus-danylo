МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи
з дисципліни «Аналіз та рефакторінг коду»
на тему «Принципи побудови підтримуваного та безпечного коду з використанням Official TypeScript Documentation для мови TypeScript»






Виконав:
ст. гр. ПЗПІ-23-10
Ходус Д.Є.



Перевірив:
Старший викл. Кафедри ПІ Сокорчук І. П.





Харків 2025


      1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень102.11.20250.1Створено “Мету роботи”, “Хід роботи з усіма описами”, “Висновок”, “Використані джерела ”202.11.20250.1Створено “Додаток А” та заповнено “Додаток Б”, “Додаток В”



      2 ЗАВДАННЯ
      Мета роботи
      Метою моєї роботи є дослідження та систематизація ключових принципів побудови підтримуваного та безпечного коду на мові програмування TypeScript, а також формування практичних навичок їх застосування. Я прагну показати, наскільки важливо використовувати головні переваги TypeScript, зокрема його потужну систему статичної типізації, для створення надійних та масштабованих програмних рішень. Це дозволяє розробникам виявляти помилки ще на етапі розробки, підвищувати читабельність коду, робити його безпечнішим і значно легшим для подальшої підтримки. Крім того, мета полягає у тому, щоб навчитися правильно структурувати проєкти, застосовувати найкращі практики іменування, форматування, обробки помилок та використовувати сучасні інструменти для аналізу якості коду, що є невід'ємною складовою підготовки сучасних фахівців з інженерії програмного забезпечення.


      3 ОПИС ВИКОНАНОЇ РОБОТИ
      Хід Роботи
     1. TypeScript сьогодні: від популярності до практики якісного коду
     Тема моєї доповіді — "Принципи побудови підтримуваного та безпечного коду на TypeScript". Чому саме ця тема є настільки важливою сьогодні? TypeScript, розроблений Microsoft, стрімко завоював популярність і став фактично стандартом у світі сучасної веб-розробки. Це не дивно, адже він є надбудовою над JavaScript, що розширює його можливості, насамперед завдяки статичній типізації. Ця ключова особливість дозволяє виявляти багато помилок ще на етапі написання коду, а не під час його виконання, що робить процес розробки більш передбачуваним та надійним. 
     Сфера застосування TypeScript величезна: від складних фронтенд-застосунків, створених на таких фреймворках, як Angular, React та Vue.js, до потужних бекенд-систем на Node.js. Його здатність структурувати код робить його незамінним інструментом для великих та масштабованих проєктів, де співпрацюють великі команди розробників. 
     Але сама по собі мова та її система типів — це лише інструмент. Важливіше те, як саме ми його використовуємо. Адже навіть на TypeScript можна написати заплутаний, нелогічний та вразливий код. Якісний код — це, по суті, текст, який ми пишемо для комп'ютера, але читатимуть його насамперед люди: колеги по команді, майбутні розробники або навіть ми самі через кілька місяців. Якщо цей текст незрозумілий, не має чіткої архітектури та не враховує потенційних загроз безпеці, він неминуче перетвориться на проблему.
     Тому тема створення підтримуваного та безпечного коду є надзвичайно актуальною. У своїй доповіді я хочу розглянути основні принципи та найкращі практики, які допоможуть зробити ваш TypeScript-код не просто функціональним, а й по-справжньому чистим, логічним, зручним для подальшої підтримки та захищеним від поширених вразливостей.
     
     2. Структура проєкту та коду
     Правильна організація файлів та коду є наступним кроком після створення читабельних назв. Уявіть, що ви зайшли до бібліотеки, де всі книги звалені в одну велику купу. Знайти потрібну було б майже неможливо. Те саме стосується і коду: якщо всі файли знаходяться в одній папці без логічної організації, проєкт швидко перетворюється на хаос. Це особливо критично для TypeScript, оскільки він заохочує поділ коду на невеликі, логічно пов'язані модулі (файли).
     Проблема безладної структури полягає в тому, що вона ускладнює навігацію, розуміння зв'язків між різними частинами програми та унеможливлює ефективну командну роботу. Коли проєкт росте, додавання нових функцій або виправлення помилок стає надзвичайно болісним процесом, оскільки важко передбачити, які частини системи будуть зачеплені змінами. Головна мета гарної структури — розділення відповідальності (Separation of Concerns), де кожен файл або папка відповідає за одну конкретну задачу чи функціонал. Це робить код більш модульним, легким для тестування та подальшої підтримки.
     Розглянемо поганий приклад (пласка структура).
     Уявімо невеликий проєкт, де всі файли знаходяться в одній папці src (Див. додаток В.1). На початковому етапі це може здаватися зручним, але зі зростанням кількості файлів така структура швидко стає некерованою.
     Чому це погано? Незрозуміло, які файли пов'язані між собою. Button.tsx може використовуватися і в профілі, і в картці товару, але логічно він є загальним елементом. В api.ts та utils.ts з часом накопичиться безліч непов'язаних функцій, що перетворить їх на "файли-звалища".
     Розглянемо  хороший приклад (структура за функціоналом). Код організовано в папки(Див. додаток В.1), що відповідають за окремі частини функціоналу (features) або за загальні, перевикористовувані елементи (shared).
     Чому це добре? Така структура є масштабованою. Легко знайти потрібний код: все, що стосується автентифікації, лежить у папці features/auth. Якщо потрібно змінити кнопку, ми знаємо, що вона знаходиться в shared/ui. Кожен модуль є самодостатнім, що спрощує його тестування та перевикористання.
     
     3. Правила іменування (Naming Conventions)
     Якщо осмислені назви — це словниковий запас нашого коду, то правила іменування — це його граматика. Недостатньо просто дати змінній зрозумілу назву; важливо робити це послідовно, дотримуючись загальноприйнятих у спільноті стандартів. Уявіть, що ви читаєте текст, де одні речення починаються з великої літери, інші — з маленької, а деякі взагалі написані ВЕЛИКИМИ ЛІТЕРАМИ без видимої причини. Такий текст важко сприймати, і він виглядає неохайно. Те саме стосується і коду.
     Проблема полягає в тому, що відсутність єдиного стилю іменування призводить до візуального безладу та плутанини. Коли один розробник називає змінні у стилі my_variable (snake_case), інший — myVariable (camelCase), а третій — MyVariable (PascalCase), код стає строкатим і важким для читання. У TypeScript це має ще більше значення, оскільки конвенції іменування допомагають миттєво розрізняти типи даних (які існують тільки на етапі компіляції) та змінні/функції (які існують під час виконання програми). Дотримання цих правил значно знижує когнітивне навантаження на програміста.
     Поганий приклад (Див. додаток В.2). Тут змішано декілька стилів, що робить код неконсистентним і змушує вчитуватися, щоб зрозуміти, де тип, а де функція чи змінна.
     Чому це погано? Назва типу user_profile не відрізняється візуально від звичайної змінної. Назва класу dataFetcher виглядає як функція. Метод FetchData можна сплутати з конструктором або компонентом.
     Хороший приклад (Див. додаток В.2). У цьому прикладі використано стандартні для TypeScript/JavaScript конвенції, що робить код передбачуваним та легким для сприйняття:
1. PascalCase для типів, інтерфейсів, класів та енумів.
2. camelCase для змінних, функцій та методів класу.
3. UPPER_SNAKE_CASE для глобальних констант.
     Чому це добре? З першого погляду зрозуміло, що UserProfile — це структура даних (тип), DataFetcher — це клас (креслення для об'єктів), а fetchData — це дія (функція/метод). Це створює чітку візуальну ієрархію та покращує загальну читабельність коду.


     4. Стильові рекомендації та форматування
     Якщо правила іменування — це граматика нашого коду, то форматування — це його пунктуація та абзаци. Уявіть, що ви намагаєтеся прочитати книгу, де немає розділів, речення злипаються, а відступи з'являються у випадкових місцях. Навіть якщо слова правильні, зрозуміти суть такого тексту буде вкрай важко. Те саме і з кодом: його зовнішній вигляд безпосередньо впливає на те, наскільки легко його зрозуміти та підтримувати.
     Проблема полягає в тому, що недбале форматування створює візуальний шум, який відволікає від логіки програми. Мозок змушений витрачати додаткові зусилля, щоб розібрати хаотичну структуру, замість того, щоб зосередитися на тому, що саме робить код. У командній роботі це стає ще більшою проблемою. Коли кожен розробник форматує код по-своєму, порівняння версій файлів (diff) перетворюється на пекло, оскільки зміни в логіці губляться серед нескінченних правок у відступах, перенесеннях рядків та лапках.
     На щастя, цю проблему майже повністю вирішують автоматичні інструменти, такі як Prettier (форматтер) та ESLint (лінтер). Вони дозволяють налаштувати єдиний стиль для всього проєкту і застосовувати його автоматично, наприклад, при збереженні файлу.
     Розглянемо  поганий приклад(Див. додаток В.3). Цей код функціонально коректний, але його форматування є вкрай неохайним і непослідовним.
     Чому це погано? Відступи хаотичні, фігурні дужки {} розташовані непослідовно, використовуються і одинарні, і подвійні лапки, а пробіли навколо операторів та після коми відсутні. Читати такий код незручно.
     Розглянемо  хорошоий приклад(Див. додаток В.3). Той самий код, але відформатований автоматично за допомогою Prettier згідно з налаштованими правилами.
     Чому це добре? Код має чітку, передбачувану структуру. Відступи, пробіли, лапки та переноси рядків уніфіковані. Будь-який розробник у команді, відкривши цей файл, побачить його в однаковому вигляді. Це дозволяє зосередитися на логіці, а не на стилі, та робить процес перегляду коду (code review) значно ефективнішим.
     
     5. Робота з типами: Найкращі практики
     Типи — це серце і душа TypeScript. Саме вони відрізняють його від JavaScript і надають головні переваги: безпеку та передбачуваність. Типи виступають у ролі "контрактів", які чітко описують, які дані очікує отримати функція, що зберігається у змінній, або яку структуру має об'єкт. Це дозволяє виявляти безліч логічних помилок ще на етапі написання коду, а не під час його виконання.
     Проблема виникає тоді, коли розробники ігнорують можливості системи типів або використовують їх неправильно. Найбільшим "ворогом" у TypeScript є тип any. Його використання фактично вимикає перевірку типів для конкретної змінної, перетворюючи частину вашого коду назад на звичайний JavaScript з усіма його потенційними проблемами. Це схоже на те, щоб мати надійний замок на дверях, але свідомо залишати його відкритим. Нечітко визначені або дубльовані типи також ускладнюють підтримку коду, оскільки зміна структури даних в одному місці не гарантує, що вона буде оновлена в іншому.
     Поганий приклад(Див. додаток В.4). Тут використовується any, що приховує потенційну помилку. Також структура користувача описується прямо в коді (inline), що унеможливлює її перевикористання.
     Чому це погано? Компілятор не може попередити нас, що об'єкт userData не має поля address. Проблема виявиться лише тоді, коли програма вже буде працювати у користувача, що є найгіршим сценарієм. Код не є самодокументованим — щоб зрозуміти, яку структуру очікує функція displayUser, потрібно читати її внутрішню логіку.
     Хороший приклад(Див. додаток В.4). Створюємо чіткі, іменовані інтерфейси для наших структур даних. Це дозволяє перевикористовувати їх і робить код безпечним та зрозумілим.
     Чому це добре?
   1. Безпека: Помилка виявляється миттєво, ще до запуску програми. Ми одразу бачимо, що передаємо невірні дані.
   2. Самодокументація: Сигнатура функції displayUser(user: User) одразу говорить нам, які дані їй потрібні.
   3. Перевикористання: Інтерфейси User та Address можна експортувати та використовувати в усьому проєкті, забезпечуючи консистентність даних.
   4. Покращена розробка: Редактор коду надає точні підказки та автодоповнення для об'єкта user, оскільки він знає його структуру.
     6. Коментарі та документування
     Хороший код часто називають "самодокументованим" — його логіка настільки прозора завдяки чітким назвам змінних і функцій, що він не потребує додаткових пояснень. Однак, у будь-якому складному проєкті настає момент, коли одного лише коду недостатньо. Коментарі та документація — це як інструкція або карта до складної системи: вони не пояснюють, як працює кожна окрема гайка, а дають загальне уявлення про архітектуру та пояснюють неочевидні рішення.
     Проблема виникає у двох крайностях. Перша — повна відсутність коментарів, що змушує майбутніх розробників (або вас самих через пів року) витрачати години, намагаючись розшифрувати складну бізнес-логіку. Друга, не менш шкідлива — надмірні та очевидні коментарі, які просто дублюють те, що і так зрозуміло з коду. Такі коментарі створюють візуальний шум і з часом застарівають, починаючи вводити в оману. Головне правило хорошого коментаря: він має пояснювати не ЩО робить код, а ЧОМУ він робить це саме так.
     У TypeScript для цього існує потужний стандарт TSDoc, який дозволяє створювати документацію, інтегровану прямо в редактор коду.
     Поганий приклад(Див. додаток В.5). Коментарі пояснюють очевидні речі, не додаючи жодної цінної інформації.
Чому це погано? Кожен коментар тут зайвий. Назва add і код a + b вже ідеально пояснюють, що відбувається. Такі коментарі лише захаращують код і змушують підтримувати їх в актуальному стані, що є марною роботою.
     Хороший приклад(Див. додаток В.4). Використовується TSDoc для опису призначення функції та звичайний коментар для пояснення неочевидної бізнес-логіки.
Чому це добре?
1. TSDoc (/** ... */): Цей блок генерує спливаючі підказки в редакторі коду, коли ви наводите курсор на назву функції. Він чітко описує призначення функції, її параметри (@param) та значення, що повертається (@returns).
2. Пояснення "Чому": Коментар // Бізнес-вимога... пояснює неочевидне рішення. Без нього інший розробник міг би "виправити" логіку, помилково вважаючи її багом, і перевіряти amount замість total.
3. Відсутність шуму: Код, який є очевидним (наприклад, total = amount * (1 + VAT_RATE)), не коментується.
     
     7. Обробка помилок
     Навіть ідеально написаний код працює в реальному світі, де будь-що може піти не так: сервер може бути недоступний, користувач може ввести некоректні дані, а файл, який ми намагаємося прочитати, може не існувати. Обробка помилок — це процес передбачення таких збоїв та створення механізмів, які дозволять програмі реагувати на них коректно, а не просто "падати".
     Проблема полягає в тому, що розробники, особливо початківці, схильні до "оптимістичного програмування" — вони пишуть код, розраховуючи, що все завжди буде працювати як очікується. Це призводить до двох поширених помилок: повне ігнорування потенційних збоїв або "проковтування" помилок, коли блок catch існує, але він порожній або просто виводить щось у консоль. В результаті, коли збій все ж трапляється, програма або аварійно завершує роботу, або переходить у нестабільний стан, а користувач бачить незрозуміле повідомлення або взагалі нічого. Якісна обробка помилок робить додаток надійним, а процес налагодження (дебаггінгу) — значно простішим.
     Розглянемо поганий приклад(Див. додаток В.6). Тут помилка, що виникає при мережевому запиті, "проковтується". Функція повертає null, але код, який її викликає, не має жодного уявлення, чому дані не були отримані.
     Чому це погано? Втрачається вся інформація про помилку. Код, що викликає функцію, не може відрізнити ситуацію "користувача не знайдено" (помилка 404) від ситуації "сервер не відповідає" (помилка 500). Це змушує показувати користувачу загальне та неконкретне повідомлення.
     Розглянемо хороший приклад(Див. додаток В.6). Використовуємо try...catch, але не для того, щоб приховати помилку, а щоб додати до неї контекст і передати її на вищий рівень для централізованої обробки.
     Чому це добре?
  1. Принцип "Fail Fast" (Швидка відмова): Функція не приховує проблему, повертаючи null, а негайно сигналізує про неї, викидаючи помилку (throw).
  2. Збереження контексту: Ми створюємо об'єкт помилки, який містить корисну інформацію (статус-код відповіді).
  3. Централізована обробка: Логіка обробки помилок винесена на вищий рівень. Функція fetchUserData відповідає лише за завантаження даних, а не за те, як показувати помилки користувачу. Це робить код більш модульним і чистим.
  4. Специфічність: Використання кастомного класу ApiError дозволяє точно визначити тип помилки і реагувати на різні ситуації по-різному.
     8. Оптимізація продуктивності
     Написання коду, який просто працює, — це лише половина справи. У реальних додатках, особливо тих, що працюють з великими обсягами даних або мають складний користувацький інтерфейс, продуктивність стає критично важливою. Повільний код призводить до "зависання" інтерфейсу, довгого завантаження та поганого користувацького досвіду, що може змусити користувачів відмовитися від вашого продукту.
     Проблема полягає в тому, що TypeScript, як і JavaScript, є мовою високого рівня, і іноді елегантні та лаконічні конструкції можуть приховувати під собою неефективні операції. Розробники можуть не задумуватися над тим, як їхній код працює "під капотом". Типовим прикладом є маніпуляції з великими масивами: створення кількох проміжних копій даних замість того, щоб обробити їх за один прохід. Це створює надмірне навантаження на пам'ять та змушує "збирач сміття" (Garbage Collector) працювати частіше, що може викликати короткочасні "завмирання" програми.
     Поганий приклад(Див. додаток В.7). Уявімо, що нам потрібно обчислити загальну вартість активних товарів, ціна яких перевищує 100 грн, у великому каталозі. Підхід з використанням ланцюжка методів filter та map виглядає читабельно, але є неефективним для великих масивів.
     Чому це погано? Кожен виклик filter або map створює абсолютно новий масив у пам'яті. Якщо початковий масив містить сотні тисяч елементів, це призводить до значних і абсолютно зайвих витрат пам'яті та процесорного часу на ітерацію по декількох великих масивах поспіль.
     Хороший приклад(Див. додаток В.7). Тієї ж мети можна досягти за один-єдиний прохід по масиву, використовуючи метод reduce або звичайний цикл for...of. Це дозволяє уникнути створення будь-яких проміжних масивів.
     Чому це добре?
   1. Ефективність пам'яті: Код не створює жодного нового масиву. Використовується лише одна додаткова змінна (sum) для накопичення результату.
   2. Швидкість: Масив products перебирається лише один раз, незалежно від його розміру.
   3. Масштабованість: Такий підхід буде працювати значно швидше на великих об'ємах даних, де різниця в продуктивності може сягати десятків і навіть сотень разів. Це демонструє, як вибір правильного алгоритму є ключовим для оптимізації.
     9. Тестування коду
     Навіть ідеально структурований, відформатований та документований код не застрахований від помилок. TypeScript чудово справляється з виявленням помилок, пов'язаних з типами, але він не може перевірити бізнес-логіку. Наприклад, компілятор не знає, що знижка для VIP-клієнта має бути 20%, а не 10%. Тестування — це процес автоматичної перевірки того, що ваш код працює саме так, як ви очікуєте, за різних умов та сценаріїв.
     Проблема полягає в тому, що відсутність автоматизованих тестів перетворює кожну зміну в коді на ризиковану лотерею. Розробники бояться вносити правки (проводити рефакторинг), оскільки неможливо вручну перевірити всі частини великого додатку і переконатися, що нічого не зламалося. Це призводить до того, що код "загниває", стає крихким, а виправлення однієї помилки часто породжує кілька нових. У кінцевому підсумку, баги знаходять кінцеві користувачі, що завдає шкоди репутації продукту та вимагає термінових і стресових виправлень.
     Розлянемо поганий приклад(Див. додаток В.8). Ось функція, яка розраховує вартість доставки. Її логіка не є тривіальною: вона залежить від суми замовлення та регіону. Без тестів ми не можемо бути впевнені, що всі комбінації умов працюють правильно.
     Чому це погано? На перший погляд, код виглядає коректно, але в ньому прихована помилка: для регіонів умова orderAmount > 2000 означає, що при замовленні рівно на 2000 грн клієнт заплатить за доставку, хоча не повинен. Без тестів цю помилку легко пропустити. Крім того, якщо в майбутньому додадуться нові регіони або зміняться ліміти, перевірити коректність роботи стане ще складніше.
     Розглянемо хороший приклад(Див. додаток В.8). Напишемо набір автоматизованих юніт-тестів (наприклад, використовуючи фреймворк Jest), які перевіряють кожен сценарій роботи нашої функції.
     
     Чому це добре?
  1. Виявлення помилок: Тести негайно виявлять логічну помилку з > 2000 замість >= 2000. Ми дізнаємося про проблему ще до того, як код потрапить до користувачів.
  2. Захист від регресій: Якщо в майбутньому хтось випадково змінить логіку, тести впадуть, сигналізуючи про те, що щось зламалося. Це створює "систему безпеки" для вашого коду.
  3. Жива документація: Тести наочно демонструють, як саме має працювати функція за різних вхідних даних. Це найкращий вид документації, оскільки вона не може застаріти — якщо вона не відповідає коду, тест просто не пройде.
  4. Спрощення рефакторингу: Маючи набір тестів, ми можемо сміливо переписувати внутрішню реалізацію функції. Доки всі тести залишаються "зеленими", ми впевнені, що не змінили її поведінку.
     4. ВИСНОВКИ
     У ході виконання роботи було розглянуто ключові принципи та найкращі практики побудови підтримуваного та безпечного коду на мові TypeScript. Особливу увагу приділено використанню головної переваги мови — статичної типізації, а також таким фундаментальним аспектам, як структура проєкту, правила іменування, форматування коду та важливість якісних коментарів і документації. Застосування цих підходів є основою для створення чистого, читабельного та масштабованого програмного продукту.
     Було детально проаналізовано найкращі практики роботи з типами, які дозволяють запобігти великому класу помилок ще на етапі компіляції. Також розглянуто стратегії надійної обробки помилок, методи оптимізації продуктивності та невід'ємну роль автоматизованого тестування. Тестування виступає гарантом того, що бізнес-логіка програми працює коректно і залишається стабільною після внесення змін (рефакторингу).
     Таким чином, дотримання єдиних стандартів, грамотна робота з системою типів, впровадження автоматизованого тестування та увага до архітектури є невід'ємними складовими процесу створення сучасного, надійного та легкого в підтримці програмного забезпечення на TypeScript.
     

5 ВИКОРИСТАНІ ДЖЕРЕЛА
      1. Stack Overflow. Структура проєкту та коду. URL: https://stackoverflow.com/questions (Дата звернення: 02.11.2025)
      2. Official TypeScript Documentation. Документація мови TypeScript. URL: https://www.typescriptlang.org/docs/ (Дата звернення: 02.11.2025)
      3. Google TypeScript Style Guide. Рекомендації щодо стилю коду TypeScript. URL: https://google.github.io/styleguide/tsguide.html (Дата звернення: 02.11.2025)
      4. Airbnb TypeScript Style Guide (eslint-config-airbnb-typescript). Правила форматування та стилю коду. URL: https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb (Дата звернення: 02.11.2025)
      5. Basarat Ali Syed. TypeScript Deep Dive — детальний посібник із TypeScript. URL: https://basarat.gitbook.io/typescript/ (Дата звернення: 02.11.2025)
      6. Refactoring Guru. Патерни проєктування та принципи рефакторингу. URL: https://refactoring.guru/ (Дата звернення: 02.11.2025)
     
     
     

ДОДАТОК А 
Відеозапис 
Відеозапис доповіді: https://www.youtube.com/watch?v=8tdhYjuwzZg
Хронологічний опис відеозапису:
0:00 – Вступ
0:11 - Проблема хаотичної структури проєкту
0:34 - Рішення: Організація коду за бізнес-функціоналом
0:55 - Проблема непослідовного іменування
1:03 - Рішення: Стандарти іменування (PascalCase, camelCase, UPPER_SNAKE_CASE)
1:40 - Стиль та форматування: проблема та рішення (Prettier, ESLint)
2:23 - Робота з типами: небезпека використання any
3:08 - Рішення: Створення чітких типів та інтерфейсів
3:45 - Обробка помилок: проблема ігнорування помилок
4:16 - Рішення: Правильне викидання та обробка помилок
5:00 - Коментарі та документація: правило "чому, а не що" та використання TSDoc
5:44 - Оптимізація та продуктивність: проблема неефективності та її вирішення
6:30 - Тестування коду: проблема відсутності тестів бізнес-логіки
6:52 - Рішення: Написання автоматизованих тестів
7:15 - Висновок
7:46 - Використані джерела
     

ДОДАТОК Б 
Слайди презентації

Рисунок Б.1 – Титульний лист

Рисунок Б.2 – Структура проєкту: Проблема хаосу


Рисунок Б.3 – Структура проєкту: Організація за функціоналом

Рисунок Б.4 – Правила іменування (Naming Conventions)


Рисунок Б.5 – Стиль та форматування

Рисунок Б.6 – Робота з типами: Небезпека any

 Рисунок Б.7 – Робота з типами: Сила інтерфейсів

Рисунок Б.8 – Обробка помилок: "Проковтування"


Рисунок Б.9 – "Швидка відмова" (Fail Fast)

Рисунок Б.10 – Коментарі та документація
 Рисунок Б.11 – Оптимізація продуктивності

Рисунок Б.12 – Тестування: Страх змін

Рисунок Б.13 – Тестування: "Система безпеки"

Рисунок Б.14 – Висновки


Рисунок Б.15 – Використані джерела


ДОДАТОК В
Програмний код
В.1 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract1/ark-pzpi-23-10-khodus-danylo-pract1/code-examples-code-conventions.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
// Погано
/src
|-- api.ts  // Усі запити до сервера в одному файлі
|-- auth.ts // Логіка автентифікації
|-- Button.tsx // Компонент кнопки
|-- UserProfile.tsx // Компонент профілю користувача
|-- ProductCard.tsx // Компонент картки товару
|-- utils.ts // Різноманітні допоміжні функції
|-- types.ts // Усі типи та інтерфейси для проєкту
|-- main.ts
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

// Добре
/src
|-- app/                // Глобальні налаштування, стилі, провайдери
|-- pages/              // Компоненти, що відповідають за цілі сторінки
|-- features/           // Окремий бізнес-функціонал
|   |-- auth/          // Все, що стосується автентифікації
|   |   |-- ui/     // Компоненти (LoginForm, RegisterForm)
|   |   |-- model/      // Логіка, типи, хуки (useAuth, authSlice.ts)
|   |   `-- api/        // Запити (login.ts, logout.ts)
|-- shared/             // Перевикористовувані елементи для всього проєкту
|   |-- ui/           // Загальні компоненти (Button.tsx, Input.tsx)
|   |-- lib/           // Допоміжні функції (formatDate.ts)
|   |-- api/      // Базові налаштування API (axiosInstance.ts)
|    `-- types/      // Глобальні типи (index.ts)
`-- main.ts`

В.2 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract1/ark-pzpi-23-10-khodus-danylo-pract1/code-examples-code-conventions.tsx

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19// Погано
// Константа названа як звичайна змінна
const admin_user_id = 1;

// Тип названо в snake_case, що робить його схожим на змінну
type user_profile = {
  name: string;
  age: number;
};

// Клас названо в camelCase
class dataFetcher {
  // Метод названо в PascalCase, наче це клас
  async FetchData(id: number): Promise<user_profile> {
    // ...
  }
}
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19// Добре
// Константа, значення якої незмінне протягом роботи програми
const ADMIN_USER_ID = 1;

// Інтерфейс (або тип) названо в PascalCase
interface UserProfile {
  name: string;
  age: number;
}

// Клас названо в PascalCase
class DataFetcher {
  // Метод названо в camelCase
  async fetchData(id: number): Promise<UserProfile> {
    // ...
  }
}
В.3 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract1/ark-pzpi-23-10-khodus-danylo-pract1/code-examples-code-conventions.tsx

 1
 2
 3
 4
 5
 6
 7
 8
 9
10 // Погано
function GetUserDetails(user: {id:number; name: string, isActive:boolean}){
    if(user.isActive){
return `Користувач "${user.name}" (ID: ${user.id}) активний`;
    } else {
        return "Користувач неактивний"
    }
}
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13// Добре
function getUserDetails(user: {
  id: number;
  name: string;
  isActive: boolean;
}) {
  if (user.isActive) {
    return `Користувач '${user.name}' (ID: ${user.id}) активний`;
  } else {
    return'Користувач неактивний';
  }
}
В.4 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract1/ark-pzpi-23-10-khodus-danylo-pract1/code-examples-code-conventions.tsx

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17// Погано
// Використання `any` дозволяє передати що завгодно,
// що може призвести до помилки під час виконання.
function displayUser(user: any) {
  // Якщо в user не буде поля `address`, програма впаде з помилкою
  console.log(`Ім'я: ${user.name}, Місто: ${user.address.city}`);
}

const userData = {
  name: 'Іван',
  // Поле address відсутнє
};

displayUser(userData); // Помилки на етапі компіляції не буде, але буде в рантаймі


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33// Добре
// Створюємо чіткі "контракти" для наших даних
interface Address {
  city: string;
  street: string;
}

interface User {
  name: string;
  address: Address;
}

// Функція тепер чітко декларує, що очікує об'єкт типу User
function displayUser(user: User) {
  console.log(`Ім'я: ${user.name}, Місто: ${user.address.city}`);
}

const userData = {
  name: 'Іван',
  // Поле address відсутнє
};

// TypeScript НЕ дозволить скомпілювати цей код,
// оскільки userData не відповідає інтерфейсу User.
// Error: Argument of type '{ name: string; }' is not assignable
// to parameter of type 'User'. Property 'address' is missing.
displayUser(userData);
В.5 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract1/ark-pzpi-23-10-khodus-danylo-pract1/code-examples-code-conventions.tsx

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27// Погано
async function fetchUserData(userId: number) {
  try {
    const response = await fetch(`https://api.example.com/users/${userId}`);
    const data = await response.json();
    return data;
  } catch (error) {
    // Помилку "проковтнули". Ми просто виводимо її в консоль,
    // але для решти програми вона зникає.
    console.log('Щось пішло не так');
    return null; // Повернення null приховує причину збою.
  }
}

// Уявімо, що сервер недоступний. fetchUserData поверне null.
const user = await fetchUserData(1);
if (!user) {
  // Ми знаємо, що щось не так, але не знаємо, що саме:
  // користувача не існує? Сервер впав? Проблеми з мережею?
  showGenericErrorMessage();
}
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47// Добре
// Можна створити власний клас для специфічних помилок
class ApiError extends Error {
  constructor(message: string, public status: number) {
    super(message);
    this.name = 'ApiError';
  }
}

async function fetchUserData(userId: number) {
  const response = await fetch(`https://api.example.com/users/${userId}`);

  // Завжди перевіряємо, чи був запит успішним
  if (!response.ok) {
    // Створюємо інформативну помилку і "викидаємо" її
    throw new ApiError(
      `Не вдалося завантажити дані користувача.`,
      response.status
    );
  }

  return response.json();
}

try {
  const user = await fetchUserData(1);
  displayUserData(user);
} catch (error) {
  // Тепер ми можемо обробити помилку більш осмислено
  if (error instanceof ApiError) {
    if (error.status === 404) {
      showNotFoundMessage('Такого користувача не існує.');
    } else {
      showServerError(`Виникла помилка сервера: ${error.status}`);
    }
  } else {
    // Для непередбачуваних помилок
    showGenericErrorMessage();
  }
}
В.6 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract1/ark-pzpi-23-10-khodus-danylo-pract1/code-examples-code-conventions.tsx

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33// Погано
interface Product {
  id: number;
  price: number;
  isActive: boolean;
}

// Уявімо, що тут 100,000 товарів
const products: Product[] = getLargeArrayOfProducts();

function calculateTotal(products: Product[]): number {
  // 1. Створюється ПЕРШИЙ проміжний масив (наприклад, з 80,000 товарів)
  const activeProducts = products.filter(p => p.isActive);

  // 2. Створюється ДРУГИЙ проміжний масив (наприклад, з 10,000 товарів)
  const expensiveProducts = activeProducts.filter(p => p.price > 100);

  // 3. Створюється ТРЕТІЙ проміжний масив з цінами
  const prices = expensiveProducts.map(p => p.price);

  // 4. Обчислюється фінальна сума
  const total = prices.reduce((sum, price) => sum + price, 0);

  return total;
}
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22// Добре
interface Product {
  id: number;
  price: number;
  isActive: boolean;
}

const products: Product[] = getLargeArrayOfProducts();

function calculateTotal(products: Product[]): number {
  // Усі операції виконуються за один прохід по масиву
  return products.reduce((sum, product) => {
    if (product.isActive && product.price > 100) {
      return sum + product.price;
    }
    return sum; // Якщо умова не виконується, просто повертаємо поточну суму
  }, 0);
}
В.7 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKhodusDanylo/ark-pzpi-23-10-khodus-danylo/blob/main/Pract1/ark-pzpi-23-10-khodus-danylo-pract1/code-examples-code-conventions.tsx
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25// Погано
/**
 * Розраховує вартість доставки.
 * - Для Києва доставка безкоштовна при замовленні від 1000 грн.
 * - Для інших міст - при замовленні від 2000 грн.
 * - Стандартна вартість: 70 грн для Києва, 120 грн для інших міст.
 */
function calculateShippingCost(orderAmount: number, region: 'Kyiv' | 'Other') {
  if (region === 'Kyiv') {
    if (orderAmount >= 1000) {
      return 0; // Безкоштовна доставка
    }
    return 70;
  } else {
    // Для інших регіонів
    if (orderAmount > 2000) { // Помилка: має бути >=
      return 0;
    }
    return 120;
  }
}
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38// Добре
// Файл: calculateShippingCost.test.ts
// Спочатку імпортуємо нашу функцію
import { calculateShippingCost } from './calculateShippingCost';

// describe - це блок, що об'єднує групу тестів
describe('calculateShippingCost', () => {
  // Кожен 'it' - це окремий тестовий випадок
  it('має повертати 0 для Києва, якщо сума >= 1000', () => {
    expect(calculateShippingCost(1000, 'Kyiv')).toBe(0);
    expect(calculateShippingCost(1500, 'Kyiv')).toBe(0);
  });

  it('має повертати 70 для Києва, якщо сума < 1000', () => {
    expect(calculateShippingCost(999, 'Kyiv')).toBe(70);
  });

  it('має повертати 0 для інших регіонів, якщо сума >= 2000', () => {
    // Цей тест ВПАДЕ і вкаже на помилку в логіці!
    expect(calculateShippingCost(2000, 'Other')).toBe(0);
    expect(calculateShippingCost(2500, 'Other')).toBe(0);
  });

  it('має повертати 120 для інших регіонів, якщо сума < 2000', () => {
    expect(calculateShippingCost(1999, 'Other')).toBe(120);
  });
});


2


‘

